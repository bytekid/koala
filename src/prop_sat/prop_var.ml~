
(*
module type VarLit = 
  sig
    type v   (* var *)
    type l   (* lit *)
    val var_to_lit : bool -> v -> l (* pol. as bool *)
    val lit_to_var : l -> bool * v 
    val is_pos_lit : l -> bool
    val compl_lit : l -> l
    val is_compl : l -> l -> bool
    val make_var : int -> v (* pos int *)
    val make_lit : int -> l (* +- v *)	
    val get_lit_id : l -> int (* do not mix var and lit ids *)
    val get_var_id : v -> int 
    val var_to_string : v -> string
    val lit_to_string : l -> string
  end
*)

(* module IntVarLit = 
  struct 
*)
    type v = int  (* start from 1  *)
    type l = int  (* pos even, neg odd  *)

    let var_to_lit pol v = 
      if pol
      then
	(v lsl 1)
      else
	((v lsl 1) +1)    

    let is_pos_lit l = ((l mod 2) = 0)
	
    let lit_to_var l = 
      if (is_pos_lit l)
      then
	(true, (l lsr 1))
      else
	(false, (l lsr 1))
	  
    let compl_lit l = 
      let (pol,v) = lit_to_var l in
      var_to_lit (not pol) v

    let is_compl l1 l2 =
      l1 = (compl_lit l2)

    let get_var_id v = v

    let get_lit_id l = l

    let make_var n = 
      (assert (n >0));
      n
	
    let make_lit n = 
      assert (n != 0);
      let v = make_var (abs n) in
      if n > 0 
      then
	var_to_lit true v 
      else
	var_to_lit false v 

    let next_var v = v + 1
	
    let var_to_string v = string_of_int v 
	
    let lit_to_string l = 
      let (pol,v) = lit_to_var l in 
      let l_int = 
	if pol 
	then
	  v
	else
	  (-v)
      in
      string_of_int l_int
(*  end *)
    
    
module VKey 
  struct  
    type t = VarLit.v
    let compare v1 v2 = Pervasives.compare (VarLit.get_var_id v1) (VarLit.get_var_id v2)
  end
    
module VMap = Map.Make(VKey)
module VSet = Set.Make(VKey)

module LKey =  
  struct  
    type t = VarLit.l
    let compare l1 l2 = Pervasives.compare (VarLit.get_lit_id l1) (VarLit.get_lit_id l2)
  end

module LMap = Map.Make(LKey)
module LSet = Set.Make(LKey)
